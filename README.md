giftbox
=======

A lightweight Javascript library for the Option monad. Maybe there's something in it, maybe there isn't ;)

## Overview

```bash
$ npm install giftbox
```

Giftbox aims to provide a wrapper API around absent values and is highly motivated by [Scala's Option][scala-option].

One of big source of bugs in production environments is missing data represented by nulls, undefined, empty strings, etc. Traditionally calling methods on `null` or 'empty' values causes NPE's, etc. and forces developers to create disorganized utilities with null/empty checks all over the codebase, adding further complexity.

[scala-option]: http://www.scala-lang.org/api/current/index.html#scala.Option

## Using Giftbox

Giftbox provides 3 simple classes to handle optional data - `Option`, `Some` & `None`. Here's how to use them:

### Simple Examples

Lets generate an option and see what it returns:

```js
var Option = require('giftbox').Option;

Option('hello world') // returns Some
Option(undefined) // returns None
```

Where is becomes useful is when you have some logic that returns data and you need to handle that data:

```js
var userDetails = userFetcher('bob@example.com');

if(Option(userDetails).isDefined()) {
	render(userDetails);
}
```

A more functional way:

```js
Option(userDetails).map(function(details) {
	render(details);
})

// or inline:

Option(userDetails).map(render);
```

Giftbox is not only useful for wrapping returned data, but also as a return value from methods:

```js
var userFetcher = function(email) {
	return Option(userClient.findByEmail(email));
};

// this time:

userFetcher('bob@example.com').map(render);
```

Note that in the example above, not only is `userFetcher` returning data wrapped in `Option`, but the value inside is generated by calling a method - `userClient.findByEmail()`. So it's totally legal to write functions wrapped with Option inline:

```js
var email = 'bob@example.com';

Option(function() {
	return userClient.findByEmail(email);
});
```
### Advanced Examples








